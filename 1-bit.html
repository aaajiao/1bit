<!doctype html>
<html lang="zh">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Wired Brutalism: Chimera Void</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: "Courier New", Courier, monospace;
            user-select: none;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
        }

        #ui {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            background: black;
            padding: 20px;
            border: 2px solid white;
            text-align: center;
            pointer-events: none;
            mix-blend-mode: difference;
            z-index: 10;
        }

        #ui h1 {
            margin: 0 0 10px 0;
            font-size: 24px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        #ui p {
            font-size: 14px;
            margin: 5px 0;
        }

        .hidden {
            display: none !important;
        }

        /* Scanline effect */
        #scanlines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background:
                linear-gradient(rgba(18, 16, 16, 0) 50%,
                    rgba(0, 0, 0, 0.25) 50%),
                linear-gradient(90deg,
                    rgba(255, 0, 0, 0.06),
                    rgba(0, 255, 0, 0.02),
                    rgba(0, 0, 255, 0.06));
            background-size:
                100% 4px,
                6px 100%;
            pointer-events: none;
            z-index: 5;
            opacity: 0.6;
        }

        #coords {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            font-size: 12px;
            z-index: 5;
            mix-blend-mode: difference;
        }
    </style>
</head>

<body>
    <div id="ui">
        <h1>CHIMERA VOID</h1>
        <p>点击进入嵌合体废墟</p>
        <p>[W, A, S, D] 移动</p>
        <p>[SPACE] 跳跃</p>
        <p>[MOUSE] 观望</p>
    </div>

    <div id="coords">POS: 0, 0</div>
    <div id="scanlines"></div>
    <div id="canvas-container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        /**
         * 1-BIT DITHER SHADER
         */
        const DitherShader = {
            uniforms: {
                tDiffuse: { value: null },
                resolution: { value: new THREE.Vector2() },
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform vec2 resolution;
                varying vec2 vUv;

                float bayer4x4(vec2 uv) {
                    int x = int(mod(uv.x, 4.0));
                    int y = int(mod(uv.y, 4.0));
                    if (x==0){ if(y==0)return 0.0625; if(y==1)return 0.5625; if(y==2)return 0.1875; if(y==3)return 0.6875; }
                    if (x==1){ if(y==0)return 0.8125; if(y==1)return 0.3125; if(y==2)return 0.9375; if(y==3)return 0.4375; }
                    if (x==2){ if(y==0)return 0.25;   if(y==1)return 0.75;   if(y==2)return 0.125;  if(y==3)return 0.625; }
                    if (x==3){ if(y==0)return 1.0;    if(y==1)return 0.5;    if(y==2)return 0.875;  if(y==3)return 0.375; }
                    return 0.5;
                }

                void main() {
                    vec4 color = texture2D(tDiffuse, vUv);
                    float gray = dot(color.rgb, vec3(0.299, 0.587, 0.114));
                    gray = pow(gray, 1.0) * 1.4;
                    vec2 pixelCoord = gl_FragCoord.xy;
                    float threshold = bayer4x4(pixelCoord);
                    vec3 finalColor = (gray < threshold) ? vec3(0.0) : vec3(1.0);
                    gl_FragColor = vec4(finalColor, 1.0);
                }
            `,
        };

        function hash(x, z) {
            let n = Math.sin(x * 12.9898 + z * 78.233) * 43758.5453;
            return n - Math.floor(n);
        }

        let camera,
            scene,
            renderer,
            composerScene,
            composerCamera,
            renderTarget;
        let moveForward = false,
            moveBackward = false,
            moveLeft = false,
            moveRight = false;
        let canJump = false;
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        let prevTime = performance.now();
        let handsGroup, scannerLight, skyEyeGroup;

        const CHUNK_SIZE = 80;
        const RENDER_DISTANCE = 2;
        const activeChunks = {};
        let chunkGroup;

        let matSolid,
            matWire,
            matPlasma,
            matDark,
            floorMat,
            matFlowerPetal,
            matFlowerStem,
            matTreeBark,
            matLiquid,
            matFlowerCore;
        let cableShaderMat;
        let boxGeo,
            blobGeo,
            knotGeo,
            coneGeo,
            tetraGeo,
            cylinderGeo,
            sphereGeo;

        function init() {
            const container = document.getElementById("canvas-container");

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x888888);
            scene.fog = new THREE.Fog(0x888888, 20, 110);

            camera = new THREE.PerspectiveCamera(
                80,
                window.innerWidth / window.innerHeight,
                0.1,
                1000,
            );
            camera.rotation.order = "YXZ";

            renderer = new THREE.WebGLRenderer({ antialias: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(1);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.BasicShadowMap;
            container.appendChild(renderer.domElement);

            const renderScale = 0.5;
            renderTarget = new THREE.WebGLRenderTarget(
                window.innerWidth * renderScale,
                window.innerHeight * renderScale,
                {
                    minFilter: THREE.NearestFilter,
                    magFilter: THREE.NearestFilter,
                },
            );

            composerScene = new THREE.Scene();
            composerCamera = new THREE.OrthographicCamera(
                -1,
                1,
                1,
                -1,
                0,
                1,
            );
            const quad = new THREE.Mesh(
                new THREE.PlaneBufferGeometry(2, 2),
                new THREE.ShaderMaterial({
                    uniforms: {
                        tDiffuse: { value: renderTarget.texture },
                        resolution: {
                            value: new THREE.Vector2(
                                window.innerWidth * renderScale,
                                window.innerHeight * renderScale,
                            ),
                        },
                    },
                    vertexShader: DitherShader.vertexShader,
                    fragmentShader: DitherShader.fragmentShader,
                }),
            );
            composerScene.add(quad);

            const hemiLight = new THREE.HemisphereLight(
                0xffffff,
                0x111111,
                0.6,
            );
            scene.add(hemiLight);

            scannerLight = new THREE.SpotLight(0xffffff, 2.0);
            scannerLight.position.set(0, 80, 0);
            scannerLight.angle = Math.PI / 4;
            scannerLight.penumbra = 0.5;
            scannerLight.decay = 2;
            scannerLight.distance = 250;
            scannerLight.castShadow = true;
            camera.add(scannerLight);

            initAssets();
            createSkyEye(); // Fixed: restored function call
            createHands();
            chunkGroup = new THREE.Group();
            scene.add(chunkGroup);

            setupEvents();
            animate();
        }

        function initAssets() {
            matSolid = new THREE.MeshLambertMaterial({ color: 0x333333 });
            matDark = new THREE.MeshLambertMaterial({ color: 0x050505 });
            matWire = new THREE.MeshBasicMaterial({
                color: 0x333333,
                wireframe: true,
                transparent: true,
                opacity: 0.6,
            });
            matPlasma = new THREE.MeshLambertMaterial({
                color: 0x111111,
                emissive: 0x000000,
            });
            matTreeBark = new THREE.MeshLambertMaterial({
                color: 0x252525,
            });

            // Flower Materials
            matFlowerStem = new THREE.MeshLambertMaterial({
                color: 0x000000,
            });
            matFlowerPetal = new THREE.MeshPhongMaterial({
                color: 0xaaaaaa,
                emissive: 0x111111,
                specular: 0xffffff,
                shininess: 100,
                transparent: true,
                opacity: 0.9,
                side: THREE.DoubleSide,
            });
            matFlowerCore = new THREE.MeshBasicMaterial({
                color: 0xffffff,
            });

            matLiquid = new THREE.MeshPhongMaterial({
                color: 0x111111,
                specular: 0xaaaaaa,
                shininess: 60,
            });

            cableShaderMat = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    color: { value: new THREE.Color(0x000000) },
                    pulseColor: { value: new THREE.Color(0x555555) },
                },
                vertexShader: `
                    uniform float time;
                    attribute float lineDistance;
                    varying float vLineDistance;
                    void main() {
                        vLineDistance = lineDistance;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform vec3 color;
                    uniform vec3 pulseColor;
                    varying float vLineDistance;
                    void main() {
                        float pulse = step(0.9, fract(vLineDistance * 0.1 - time * 2.0));
                        vec3 finalColor = mix(color, pulseColor, pulse);
                        gl_FragColor = vec4(finalColor, 1.0);
                    }
                `,
                transparent: true,
            });

            const size = 64;
            const data = new Uint8Array(size * size * 3);
            for (let i = 0; i < size * size; i++) {
                const x = i % size;
                const y = Math.floor(i / size);
                const c = x % 4 === 0 || y % 4 === 0 ? 100 : 40;
                data[i * 3] = c;
                data[i * 3 + 1] = c;
                data[i * 3 + 2] = c;
            }
            const tex = new THREE.DataTexture(
                data,
                size,
                size,
                THREE.RGBFormat,
            );
            tex.magFilter = THREE.NearestFilter;
            tex.wrapS = THREE.RepeatWrapping;
            tex.wrapT = THREE.RepeatWrapping;
            tex.repeat.set(20, 20);
            floorMat = new THREE.MeshLambertMaterial({ map: tex });

            boxGeo = new THREE.BoxGeometry(1, 1, 1);
            blobGeo = new THREE.IcosahedronGeometry(1, 1);
            sphereGeo = new THREE.SphereGeometry(1, 16, 16);
            knotGeo = new THREE.TorusKnotGeometry(0.6, 0.2, 64, 8);
            coneGeo = new THREE.ConeGeometry(0.5, 1, 16);
            tetraGeo = new THREE.TetrahedronGeometry(1);
            cylinderGeo = new THREE.CylinderGeometry(1, 1, 1, 6);
        }

        // Fixed: Function was missing in previous iteration
        function createSkyEye() {
            skyEyeGroup = new THREE.Group();
            camera.add(skyEyeGroup);
            scene.add(camera);

            const mat = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                side: THREE.DoubleSide,
            });

            for (let i = 1; i <= 4; i++) {
                const ring = new THREE.Mesh(
                    new THREE.RingGeometry(i * 4, i * 4 + 0.5, 64),
                    mat,
                );
                ring.userData = { speed: (Math.random() - 0.5) * 0.2 };
                skyEyeGroup.add(ring);
            }

            const pupil = new THREE.Mesh(
                new THREE.CircleGeometry(2, 32),
                mat,
            );
            skyEyeGroup.add(pupil);

            skyEyeGroup.position.set(0, 80, -200);
            skyEyeGroup.lookAt(0, 0, 0);
        }

        function updateChunks() {
            const cx = Math.floor(camera.position.x / CHUNK_SIZE);
            const cz = Math.floor(camera.position.z / CHUNK_SIZE);
            const activeKeys = new Set();

            for (let x = -RENDER_DISTANCE; x <= RENDER_DISTANCE; x++) {
                for (let z = -RENDER_DISTANCE; z <= RENDER_DISTANCE; z++) {
                    const key = `${cx + x},${cz + z}`;
                    activeKeys.add(key);
                    if (!activeChunks[key]) createChunk(cx + x, cz + z);
                }
            }

            for (const key in activeChunks) {
                if (!activeKeys.has(key)) {
                    const chunk = activeChunks[key];
                    if (chunk.userData.cables) {
                        chunk.userData.cables.forEach((c) => {
                            if (c.line && c.line.geometry)
                                c.line.geometry.dispose();
                        });
                    }
                    chunkGroup.remove(chunk);
                    delete activeChunks[key];
                }
            }
            document.getElementById("coords").innerText =
                `POS: ${Math.round(camera.position.x)}, ${Math.round(camera.position.z)}`;
        }

        function createChunk(cx, cz) {
            const chunk = new THREE.Group();
            chunk.position.set(cx * CHUNK_SIZE, 0, cz * CHUNK_SIZE);
            chunk.userData = { cables: [], buildings: [] };

            const floor = new THREE.Mesh(
                new THREE.PlaneGeometry(CHUNK_SIZE, CHUNK_SIZE),
                floorMat,
            );
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            chunk.add(floor);

            const chunkSeed = hash(cx, cz);
            const numBuildings = 3 + Math.floor(hash(cx, cz + 1) * 5);
            const nodes = [];

            for (let i = 0; i < numBuildings; i++) {
                const bx = (hash(cx + i, cz) - 0.5) * (CHUNK_SIZE - 20);
                const bz = (hash(cx, cz + i) - 0.5) * (CHUNK_SIZE - 20);

                const buildGroup = new THREE.Group();
                buildGroup.position.set(bx, 0, bz);

                const styleSeed = hash(i, cx);
                let style = "BLOCKS";

                if (styleSeed > 0.9) style = "FLUID";
                else if (styleSeed > 0.7) style = "TREE";
                else if (styleSeed > 0.35) style = "SPIKES";
                else style = "BLOCKS";

                let isMobile = false;
                if (style !== "TREE") {
                    isMobile = hash(i, i) > 0.3;
                }

                buildGroup.userData = {
                    initialPos: buildGroup.position.clone(),
                    wanderSpeed: 0.2 + hash(i, i) * 0.3,
                    wanderRange: 2.0 + hash(i, cx) * 5.0,
                    offset: hash(i, cz) * 100,
                    isMobile: isMobile,
                };

                let maxHeight = 0;

                // === STYLE: TREE ===
                if (style === "TREE") {
                    const sizeGene = hash(i, cz * cx);
                    const globalScale = 0.5 + Math.pow(sizeGene, 4) * 4.0;

                    const trunkHeightBase = 10 + hash(i, cz) * 10;
                    const trunkHeight = trunkHeightBase * globalScale;

                    const trunkWidthBase = 0.8 + hash(i, cx) * 1.2;
                    const trunkBaseWidth = trunkWidthBase * globalScale;

                    const leanAmount =
                        (hash(i, i) - 0.5) * (2.0 + hash(cx, i) * 4.0);
                    const leanDirX = Math.sin(hash(i, 0) * Math.PI * 2);
                    const leanDirZ = Math.cos(hash(i, 0) * Math.PI * 2);

                    const shapeProfile = Math.floor(
                        hash(i, trunkHeight) * 3,
                    );

                    const segmentCount = Math.max(
                        2,
                        Math.floor(trunkHeight / 3),
                    );

                    for (let t = 0; t < segmentCount; t++) {
                        const tRatio = t / segmentCount;
                        const nextTRatio = (t + 1) / segmentCount;
                        const segHeight = trunkHeight / segmentCount;

                        const taper = 1.0 - Math.pow(tRatio, 1.5) * 0.8;
                        const wBottom = trunkBaseWidth * taper;

                        const seg = new THREE.Mesh(
                            cylinderGeo,
                            matTreeBark,
                        );
                        seg.scale.set(wBottom, segHeight, wBottom);

                        const leanCurve =
                            Math.pow(tRatio, 1.5) * leanAmount;
                        const curveX = leanDirX * leanCurve;
                        const curveZ = leanDirZ * leanCurve;

                        const wiggle =
                            Math.sin(t * 1.5 + hash(i, 0) * 10) *
                            (trunkBaseWidth * 0.3);

                        seg.position.set(
                            curveX + wiggle,
                            t * segHeight + segHeight / 2,
                            curveZ + wiggle,
                        );

                        seg.rotation.z =
                            -(leanDirX * leanAmount * 0.05) +
                            (hash(t, i) - 0.5) * 0.1;
                        seg.rotation.x =
                            leanDirZ * leanAmount * 0.05 +
                            (hash(i, t) - 0.5) * 0.1;
                        seg.rotation.y = hash(t, t) * 0.5;

                        seg.castShadow = true;
                        seg.receiveShadow = true;
                        buildGroup.add(seg);
                    }

                    const levels =
                        2 +
                        Math.floor(hash(i, i) * 3) +
                        (globalScale > 2 ? 2 : 0);
                    const canopyStartRatio = 0.2 + hash(i, cx) * 0.6;

                    for (let l = 0; l < levels; l++) {
                        const lRatio = l / Math.max(1, levels - 1);
                        const minH = trunkHeight * canopyStartRatio;
                        const currentHeight =
                            minH + (trunkHeight - minH) * lRatio;

                        const tRatioGlobal = currentHeight / trunkHeight;
                        const leanCurve =
                            Math.pow(tRatioGlobal, 1.5) * leanAmount;
                        const trunkX = leanDirX * leanCurve;
                        const trunkZ = leanDirZ * leanCurve;

                        let reachBase = 5 * globalScale;
                        if (shapeProfile === 0)
                            reachBase =
                                reachBase * (1.0 - lRatio * 0.8) + 2;
                        else if (shapeProfile === 1)
                            reachBase =
                                reachBase * Math.sin(lRatio * Math.PI) + 2;
                        else reachBase = reachBase * (0.5 + lRatio) + 2;

                        const branches =
                            2 + Math.floor(hash(l, i) * (3 + globalScale));

                        for (let b = 0; b < branches; b++) {
                            const angle =
                                (b / branches) * Math.PI * 2 +
                                l * 1.5 +
                                hash(b, l);
                            const reach =
                                reachBase * (0.7 + hash(b, l) * 0.6);

                            const branch = new THREE.Mesh(
                                coneGeo,
                                matTreeBark,
                            );
                            const bGroup = new THREE.Group();

                            bGroup.position.set(
                                trunkX,
                                currentHeight,
                                trunkZ,
                            );
                            bGroup.rotation.y = angle;

                            const droopGene = hash(i, b) > 0.5 ? 1 : -1;
                            const angleUp =
                                Math.PI / 2.5 -
                                lRatio * 0.8 +
                                (hash(b, i) - 0.5) * 0.3 * droopGene;

                            bGroup.userData = {
                                animType: "BRANCH_SWAY",
                                initialRotZ: angleUp,
                                speed: 0.5 + hash(b, l),
                                phase: hash(l, b) * Math.PI,
                                rigidity:
                                    (1.0 - lRatio * 0.5) *
                                    (globalScale > 2 ? 2.0 : 1.0),
                            };
                            bGroup.rotation.z = angleUp;

                            branch.scale.set(
                                trunkBaseWidth * 0.15,
                                reach,
                                trunkBaseWidth * 0.15,
                            );
                            branch.position.y = reach / 2;
                            bGroup.add(branch);

                            const clusterSize =
                                2 + Math.floor(hash(b, l) * 4);
                            const clusterSpread =
                                (1.0 + hash(l, b) * 2.0) *
                                globalScale *
                                0.5;

                            for (let leaf = 0; leaf < clusterSize; leaf++) {
                                const leafMesh = new THREE.Mesh(
                                    tetraGeo,
                                    matWire,
                                );
                                const ls =
                                    (0.8 + hash(leaf, b) * 1.5) *
                                    globalScale *
                                    0.6;
                                leafMesh.scale.set(ls, ls, ls);

                                leafMesh.position.set(
                                    (hash(leaf, 0) - 0.5) * clusterSpread,
                                    reach +
                                    (hash(leaf, 1) - 0.5) *
                                    clusterSpread,
                                    (hash(leaf, 2) - 0.5) * clusterSpread,
                                );

                                leafMesh.userData = {
                                    animType: "LEAF_FLUTTER",
                                    speed: 2.0 + hash(leaf, l) * 2.0,
                                    phase: hash(leaf, i) * Math.PI,
                                    baseScale: leafMesh.scale.clone(),
                                };

                                if (hash(leaf, i) > 0.95) {
                                    const fruit = new THREE.Mesh(
                                        blobGeo,
                                        matPlasma.clone(),
                                    );
                                    const fs = 0.5 * globalScale;
                                    fruit.scale.set(fs, fs, fs);
                                    fruit.position.copy(leafMesh.position);
                                    fruit.position.y -= ls;
                                    fruit.userData = {
                                        isPlasma: true,
                                        animType: "LEAF_FLUTTER",
                                        speed: 1.0,
                                        phase: 0,
                                    };
                                    bGroup.add(fruit);
                                }

                                bGroup.add(leafMesh);
                            }

                            buildGroup.add(bGroup);
                        }
                    }
                    maxHeight = trunkHeight + 5;
                } else {
                    // === OLDER STYLES (FLUID, SPIKES, BLOCKS) ===
                    let fragments = 4 + Math.floor(hash(i, cz) * 8);
                    for (let f = 0; f < fragments; f++) {
                        let mesh;
                        const r1 = hash(i + f, cx);
                        const r2 = hash(cx, cz + f);
                        const r3 = hash(f, i);
                        let yPos, xOffset, zOffset;

                        if (style === "FLUID") {
                            const isLiquid = hash(f, i) > 0.5;
                            if (!isLiquid) {
                                const assetType = hash(f, cx);
                                let chosenGeo, chosenMat;
                                if (assetType > 0.8) {
                                    chosenGeo = knotGeo;
                                    chosenMat = matSolid;
                                } else if (assetType > 0.6) {
                                    chosenGeo = coneGeo;
                                    chosenMat = matDark;
                                } else if (assetType > 0.4) {
                                    chosenGeo = tetraGeo;
                                    chosenMat = matWire;
                                } else if (assetType > 0.2) {
                                    chosenGeo = cylinderGeo;
                                    chosenMat = matTreeBark;
                                } else {
                                    chosenGeo = boxGeo;
                                    chosenMat = matSolid;
                                }

                                if (hash(f, cz) > 0.9)
                                    chosenMat = matPlasma.clone();

                                mesh = new THREE.Mesh(chosenGeo, chosenMat);
                                const scaleMod = 1.0 + r2 * 1.5;
                                if (chosenGeo === coneGeo)
                                    mesh.scale.set(
                                        scaleMod,
                                        scaleMod * 3,
                                        scaleMod,
                                    );
                                else if (chosenGeo === tetraGeo)
                                    mesh.scale.set(
                                        scaleMod * 2,
                                        scaleMod * 2,
                                        scaleMod * 2,
                                    );
                                else
                                    mesh.scale.set(
                                        scaleMod * 2,
                                        scaleMod * 1.5,
                                        scaleMod * 2,
                                    );

                                mesh.rotation.set(
                                    r1 * Math.PI * 2,
                                    r2 * Math.PI * 2,
                                    r3 * Math.PI * 2,
                                );
                                yPos = f * 2.5;
                                xOffset = (r2 - 0.5) * 5;
                                zOffset = (r3 - 0.5) * 5;
                                mesh.userData.baseScale =
                                    mesh.scale.clone();
                                if (assetType > 0.7) {
                                    mesh.userData.animType = "ROTATE_FLOAT";
                                    mesh.userData.speed = 0.2;
                                }
                            } else {
                                mesh = new THREE.Mesh(sphereGeo, matLiquid);
                                const stretch = 1.0 + r1 * 2.0;
                                mesh.scale.set(
                                    2.0 + r2,
                                    2.0 * stretch,
                                    2.0 + r3,
                                );
                                mesh.userData = {
                                    animType: "LIQUID_WOBBLE",
                                    speed: 0.8 + r2,
                                    phase: f + r1 * 5,
                                    baseScale: mesh.scale.clone(),
                                };
                                yPos = f * 2.5 + (r1 - 0.5) * 2;
                                xOffset = (r2 - 0.5) * 6;
                                zOffset = (r3 - 0.5) * 6;
                                mesh.rotation.z = (r1 - 0.5) * 0.5;
                            }
                        } else {
                            mesh = new THREE.Mesh(
                                style === "SPIKES" ? coneGeo : boxGeo,
                                style === "SPIKES" ? matDark : matSolid,
                            );
                            if (style === "SPIKES") {
                                mesh.scale.set(1 + r2, 4 + r3 * 6, 1 + r2);
                                yPos = f * 3.5;
                                xOffset = (r2 - 0.5) * 6;
                                zOffset = (r3 - 0.5) * 6;
                            } else {
                                mesh.scale.set(
                                    2 + r2 * 4,
                                    3 + r3 * 4,
                                    2 + r2 * 4,
                                );
                                yPos = f * 3.5;
                                xOffset = (r2 - 0.5) * 5;
                                zOffset = (r3 - 0.5) * 5;
                            }
                            mesh.userData.baseScale = mesh.scale.clone();
                        }

                        mesh.castShadow = true;
                        mesh.receiveShadow = true;
                        mesh.position.set(xOffset, yPos, zOffset);
                        buildGroup.add(mesh);

                        const topY = yPos + mesh.scale.y * 1.5;
                        if (topY > maxHeight) maxHeight = topY;
                    }
                }

                chunk.add(buildGroup);
                nodes.push({
                    obj: buildGroup,
                    topOffset: new THREE.Vector3(0, maxHeight, 0),
                    isGround: false,
                });

                chunk.userData.buildings.push(buildGroup);
            }

            // --- CABLES ---
            if (nodes.length > 0) {
                if (nodes.length > 1) {
                    for (let i = 0; i < nodes.length - 1; i++) {
                        const startNode = nodes[i];
                        const endNode = nodes[i + 1];
                        const strands = 1 + (hash(i, cx) > 0.5 ? 1 : 0);

                        for (let s = 0; s < strands; s++) {
                            const cable = createDynamicCable(
                                startNode,
                                endNode,
                                {
                                    droop: 5 + hash(i, s) * 10,
                                    heavySag: hash(i, i) > 0.8,
                                    offsetS: new THREE.Vector3(
                                        (hash(s, i) - 0.5) * 2,
                                        0,
                                        (hash(i, s) - 0.5) * 2,
                                    ),
                                    offsetE: new THREE.Vector3(
                                        (hash(s, i + 1) - 0.5) * 2,
                                        0,
                                        (hash(i + 1, s) - 0.5) * 2,
                                    ),
                                },
                            );
                            chunk.add(cable.line);
                            chunk.userData.cables.push(cable);
                        }
                    }
                }

                for (let i = 0; i < nodes.length; i++) {
                    if (hash(i, cx) > 0.6) {
                        const startNode = nodes[i];
                        const numDangles = 1 + Math.floor(hash(i, cz) * 2);

                        for (let k = 0; k < numDangles; k++) {
                            const angle = hash(k, i) * Math.PI * 2;
                            const dist = 10 + hash(i, k) * 15;
                            const groundPos = startNode.obj.position
                                .clone()
                                .add(
                                    new THREE.Vector3(
                                        Math.cos(angle) * dist,
                                        0,
                                        Math.sin(angle) * dist,
                                    ),
                                );
                            groundPos.y = 0.1;

                            const groundNode = {
                                obj: { position: groundPos },
                                topOffset: new THREE.Vector3(0, 0, 0),
                                isGround: true,
                            };

                            const cable = createDynamicCable(
                                startNode,
                                groundNode,
                                {
                                    droop: 2,
                                    heavySag: false,
                                    offsetS: new THREE.Vector3(
                                        hash(k, i) - 0.5,
                                        0,
                                        hash(i, k) - 0.5,
                                    ),
                                    offsetE: new THREE.Vector3(0, 0, 0),
                                },
                            );
                            chunk.add(cable.line);
                            chunk.userData.cables.push(cable);
                        }
                    }
                }
            }

            activeChunks[`${cx},${cz}`] = chunk;
            chunkGroup.add(chunk);
        }

        function createDynamicCable(startNode, endNode, options) {
            const segments = 12;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array((segments + 1) * 3);
            const distances = new Float32Array(segments + 1);
            geometry.setAttribute(
                "position",
                new THREE.BufferAttribute(positions, 3),
            );
            geometry.setAttribute(
                "lineDistance",
                new THREE.BufferAttribute(distances, 1),
            );
            const line = new THREE.Line(geometry, cableShaderMat);
            line.frustumCulled = false;
            return { line, startNode, endNode, options, segments };
        }

        function createHands() {
            handsGroup = new THREE.Group();
            camera.add(handsGroup);

            const handMat = new THREE.MeshLambertMaterial({
                color: 0x555555,
            });
            const jointMat = new THREE.MeshLambertMaterial({
                color: 0x444444,
            });
            const handLight = new THREE.DirectionalLight(0xffffff, 0.5);
            handLight.position.set(0, 2, 0);
            handsGroup.add(handLight);

            // --- HELPER: ANATOMICAL FINGER ---
            function createFinger(length, width, curlStart) {
                const root = new THREE.Group();

                // Phalanges lengths based on golden ratio approx
                const l1 = length * 0.45;
                const l2 = length * 0.3;
                const l3 = length * 0.25;
                const w = width;

                // 1. Proximal Phalanx
                const s1 = new THREE.Mesh(
                    new THREE.BoxGeometry(w, w * 0.85, l1),
                    handMat,
                );
                s1.position.z = -l1 / 2;
                root.add(s1);

                // Joint 1 (PIP)
                const j1 = new THREE.Mesh(
                    new THREE.SphereGeometry(w * 0.55, 8, 8),
                    jointMat,
                );
                j1.position.z = -l1;
                root.add(j1);

                // 2. Middle Phalanx
                const s2Group = new THREE.Group();
                s2Group.position.z = -l1;
                root.add(s2Group);

                const s2 = new THREE.Mesh(
                    new THREE.BoxGeometry(w * 0.9, w * 0.8, l2),
                    handMat,
                );
                s2.position.z = -l2 / 2;
                s2Group.add(s2);

                // Joint 2 (DIP)
                const j2 = new THREE.Mesh(
                    new THREE.SphereGeometry(w * 0.5, 8, 8),
                    jointMat,
                );
                j2.position.z = -l2;
                s2Group.add(j2);

                // 3. Distal Phalanx (Tip)
                const s3Group = new THREE.Group();
                s3Group.position.z = -l2;
                s2Group.add(s3Group);

                const s3 = new THREE.Mesh(
                    new THREE.BoxGeometry(w * 0.8, w * 0.7, l3),
                    handMat,
                );
                s3.position.z = -l3 / 2;
                s3Group.add(s3);

                return {
                    root,
                    s1,
                    s2: s2Group,
                    s3: s3Group,
                    tip: s3,
                    length: length,
                };
            }

            // --- HELPER: ANATOMICAL THUMB ---
            function createThumb(width) {
                const root = new THREE.Group();
                const l1 = 0.14; // Metacarpal (hidden inside palm/thenar)
                const l2 = 0.12; // Proximal
                const l3 = 0.1; // Distal

                // Segment 1 (Proximal)
                const s1Group = new THREE.Group();
                root.add(s1Group);

                const s1 = new THREE.Mesh(
                    new THREE.BoxGeometry(width, width * 0.9, l2),
                    handMat,
                );
                s1.position.z = -l2 / 2;
                s1Group.add(s1);

                // Joint 1 (MCP)
                const j1 = new THREE.Mesh(
                    new THREE.SphereGeometry(width * 0.55, 8, 8),
                    jointMat,
                );
                j1.position.z = -l2;
                s1Group.add(j1);

                // Segment 2 (Distal)
                const s2Group = new THREE.Group();
                s2Group.position.z = -l2;
                s1Group.add(s2Group);

                const s2 = new THREE.Mesh(
                    new THREE.BoxGeometry(width * 0.9, width * 0.8, l3),
                    handMat,
                );
                s2.position.z = -l3 / 2;
                s2Group.add(s2);

                return { root, s1: s1Group, s2: s2Group };
            }

            function createHandModel(isLeft) {
                const g = new THREE.Group();

                // === NEW: Hand Geometry Container ===
                // We put all hand parts in here so we can move the hand WITHOUT moving the flower
                const handMeshGroup = new THREE.Group();
                g.add(handMeshGroup);

                // 1. FOREARM
                const armGeo = new THREE.CylinderGeometry(
                    0.09,
                    0.13,
                    3.5,
                    10,
                );
                const arm = new THREE.Mesh(armGeo, handMat);
                arm.rotation.x = Math.PI / 2;
                arm.scale.set(1.2, 1, 0.85);
                arm.position.z = 1.85;
                handMeshGroup.add(arm); // Add to mesh group

                // 2. WRIST
                const wrist = new THREE.Mesh(
                    new THREE.BoxGeometry(0.22, 0.08, 0.1),
                    jointMat,
                );
                wrist.position.z = 0.15;
                handMeshGroup.add(wrist);

                // 3. PALM
                const palmGroup = new THREE.Group();
                handMeshGroup.add(palmGroup);

                const palmGeo = new THREE.BoxGeometry(0.26, 0.06, 0.32);
                const palm = new THREE.Mesh(palmGeo, handMat);
                palm.position.z = -0.05;
                palmGroup.add(palm);

                // Muscles
                const thenarGeo = new THREE.SphereGeometry(0.08, 12, 12);
                const thenar = new THREE.Mesh(thenarGeo, handMat);
                thenar.scale.set(1.0, 0.6, 1.4);
                thenar.position.set(isLeft ? 0.1 : -0.1, -0.04, 0.02);
                thenar.rotation.z = isLeft ? -0.3 : 0.3;
                palmGroup.add(thenar);

                const hypoGeo = new THREE.SphereGeometry(0.06, 12, 12);
                const hypo = new THREE.Mesh(hypoGeo, handMat);
                hypo.scale.set(0.8, 0.5, 1.2);
                hypo.position.set(isLeft ? -0.1 : 0.1, -0.04, 0.05);
                palmGroup.add(hypo);

                // 4. FINGERS (Rigging)
                const fIndex = createFinger(0.38, 0.065);
                fIndex.root.position.set(isLeft ? 0.1 : -0.1, 0, -0.21);
                fIndex.root.rotation.y = isLeft ? -0.05 : 0.05;
                handMeshGroup.add(fIndex.root);

                const fMid = createFinger(0.42, 0.068);
                fMid.root.position.set(0, 0, -0.22);
                handMeshGroup.add(fMid.root);

                const fRing = createFinger(0.39, 0.065);
                fRing.root.position.set(isLeft ? -0.1 : 0.1, 0, -0.21);
                fRing.root.rotation.y = isLeft ? 0.03 : -0.03;
                handMeshGroup.add(fRing.root);

                const fPinky = createFinger(0.3, 0.055);
                fPinky.root.position.set(
                    isLeft ? -0.19 : 0.19,
                    -0.01,
                    -0.19,
                );
                fPinky.root.rotation.y = isLeft ? 0.15 : -0.15;
                handMeshGroup.add(fPinky.root);

                // 5. THUMB
                const fThumb = createThumb(0.075);
                fThumb.root.position.set(
                    isLeft ? 0.16 : -0.16,
                    -0.02,
                    -0.02,
                );
                fThumb.root.rotation.y = isLeft ? -0.8 : 0.8;
                fThumb.root.rotation.x = 0.2;
                handMeshGroup.add(fThumb.root);

                // --- POSING & INTERACTION ---
                if (!isLeft) {
                    // === RIGHT HAND: CORRECTED GRIP ===

                    // 1. RE-ORIENT THE HAND MESH ITSELF (The "Inside-Out" Rotation)
                    // We rotate the geometry group AROUND the flower's location relative to the wrist

                    // Supination: Rotate around Z/Y axis so palm faces up/left
                    handMeshGroup.rotation.z = -0.5; // Tilt wrist left
                    handMeshGroup.rotation.y = -0.3; // Turn palm in
                    handMeshGroup.rotation.x = -0.2; // Tilt back

                    // Adjust position to align "grip center" with the flower's existing position
                    // Flower is at (-0.05, 0.05, -0.25) relative to parent G
                    handMeshGroup.position.set(0.05, 0.1, 0.0);

                    // 2. FINGER CURL (Downward Grip - FIXING DIRECTION)
                    // Changing positive rotations to negative to curl INTO the palm

                    [fIndex, fMid, fRing, fPinky].forEach((f, i) => {
                        // Knuckle: Bend INWARD (Negative)
                        f.root.rotation.x = -1.5 - i * 0.1;
                        // Mid joint: Curl tightly
                        f.s2.rotation.x = -1.2;
                        // Tip: Dig in
                        f.s3.rotation.x = -0.8;
                    });

                    // 3. THUMB LOCK
                    // Swing thumb across palm (Y rotation)
                    fThumb.root.rotation.y = 1.5;
                    // Point thumb down towards fingers (X rotation)
                    fThumb.root.rotation.x = 0.5;

                    // Curl thumb joints INWARD (Negative)
                    fThumb.s1.rotation.x = -0.3;
                    fThumb.s2.rotation.x = -0.7; // Pressing down

                    // === FLOWER PLACEMENT (UNTOUCHED TRANSFORM VALUES) ===
                    const flowerGroup = new THREE.Group();

                    // KEEPING THESE EXACTLY AS THEY WERE IN PREVIOUS VERSION
                    flowerGroup.position.set(-0.05, 0.05, -0.25);
                    flowerGroup.rotation.set(0.1, -0.1, 0.1);

                    const stemCurve = new THREE.CatmullRomCurve3([
                        new THREE.Vector3(0, -2.0, 0),
                        new THREE.Vector3(0.01, -0.5, 0.01),
                        new THREE.Vector3(0, 0, 0),
                        new THREE.Vector3(-0.01, 0.6, -0.02),
                        new THREE.Vector3(0, 0.8, 0),
                    ]);
                    const stemGeo = new THREE.TubeGeometry(
                        stemCurve,
                        12,
                        0.012,
                        6,
                        false,
                    );
                    const stem = new THREE.Mesh(stemGeo, matFlowerStem);
                    flowerGroup.add(stem);

                    const bloom = new THREE.Group();
                    bloom.position.set(0, 0.8, 0);

                    const coreLight = new THREE.PointLight(
                        0xffffff,
                        3.0,
                        8.0,
                    );
                    coreLight.castShadow = true;
                    coreLight.shadow.bias = -0.0001;
                    bloom.add(coreLight);

                    const coreMesh = new THREE.Mesh(
                        new THREE.IcosahedronGeometry(0.07, 1),
                        matFlowerCore,
                    );
                    bloom.add(coreMesh);

                    for (let p = 0; p < 7; p++) {
                        const angle = (p / 7) * Math.PI * 2;
                        const petal = new THREE.Mesh(
                            new THREE.ConeGeometry(0.05, 0.5, 3),
                            matFlowerPetal,
                        );
                        petal.position.set(
                            Math.sin(angle) * 0.08,
                            0.2,
                            Math.cos(angle) * 0.08,
                        );
                        petal.lookAt(0, 0, 0);
                        petal.rotation.x -= 2.2;
                        petal.userData = {
                            animType: "PETAL_BREATHE",
                            baseRotX: petal.rotation.x,
                            phase: p,
                        };
                        bloom.add(petal);
                    }

                    for (let s = 0; s < 5; s++) {
                        const angle = (s / 5) * Math.PI * 2 + 0.5;
                        const sepal = new THREE.Mesh(
                            new THREE.TetrahedronGeometry(0.2),
                            matWire,
                        );
                        sepal.position.set(
                            Math.sin(angle) * 0.12,
                            0.05,
                            Math.cos(angle) * 0.12,
                        );
                        sepal.rotation.set(
                            Math.random(),
                            Math.random(),
                            Math.random(),
                        );
                        sepal.userData = {
                            animType: "SEPAL_FLOAT",
                            phase: s * 2,
                            speed: 0.6,
                        };
                        bloom.add(sepal);
                    }

                    const pGeo = new THREE.BoxGeometry(0.012, 0.012, 0.012);
                    for (let d = 0; d < 16; d++) {
                        const dust = new THREE.Mesh(pGeo, matFlowerCore);
                        const r = 0.3 + Math.random() * 0.3;
                        const theta = Math.random() * Math.PI * 2;
                        const phi = Math.random() * Math.PI;
                        dust.position.set(
                            r * Math.sin(phi) * Math.cos(theta),
                            r * Math.cos(phi),
                            r * Math.sin(phi) * Math.sin(theta),
                        );
                        dust.userData = {
                            animType: "DUST_ORBIT",
                            axis: new THREE.Vector3(
                                Math.random() - 0.5,
                                Math.random() - 0.5,
                                Math.random() - 0.5,
                            ).normalize(),
                            speed: 0.4 + Math.random(),
                        };
                        bloom.add(dust);
                    }

                    flowerGroup.add(bloom);
                    flowerGroup.userData = { bloom: bloom };

                    // IMPORTANT: Add flower directly to G (Parent), NOT handMeshGroup
                    // This ensures moving handMeshGroup doesn't move the flower
                    g.add(flowerGroup);
                } else {
                    fIndex.root.rotation.x = 0.2;
                    fIndex.s2.rotation.x = 0.2;
                    fIndex.s3.rotation.x = 0.1;
                    fMid.root.rotation.x = 0.25;
                    fMid.s2.rotation.x = 0.25;
                    fMid.s3.rotation.x = 0.1;
                    fRing.root.rotation.x = 0.3;
                    fRing.s2.rotation.x = 0.3;
                    fRing.s3.rotation.x = 0.15;
                    fPinky.root.rotation.x = 0.35;
                    fPinky.s2.rotation.x = 0.35;
                    fPinky.s3.rotation.x = 0.15;
                    fThumb.root.rotation.x = 0.3;
                    fThumb.s2.rotation.x = 0.2;
                }

                return g;
            }

            const l = createHandModel(true);
            l.position.set(-0.55, -0.6, -0.85);
            l.rotation.set(-0.3, -0.2, -0.15);
            handsGroup.add(l);

            // Right Hand: Rotate slightly more to show the "Grip" (Palm facing left/in)
            const r = createHandModel(false);
            r.position.set(0.6, -0.7, -0.9); // Lower and to the side slightly
            r.rotation.set(-0.2, 0.4, 0.3); // Tilted inward to show the flower held up
            handsGroup.add(r);

            handsGroup.userData = { left: l, right: r, time: 0 };
        }

        function setupEvents() {
            document.addEventListener("keydown", (e) => {
                switch (e.code) {
                    case "KeyW":
                        moveForward = true;
                        break;
                    case "KeyA":
                        moveLeft = true;
                        break;
                    case "KeyS":
                        moveBackward = true;
                        break;
                    case "KeyD":
                        moveRight = true;
                        break;
                    case "Space":
                        if (canJump) {
                            velocity.y += 15;
                            canJump = false;
                        }
                        break;
                }
            });
            document.addEventListener("keyup", (e) => {
                switch (e.code) {
                    case "KeyW":
                        moveForward = false;
                        break;
                    case "KeyA":
                        moveLeft = false;
                        break;
                    case "KeyS":
                        moveBackward = false;
                        break;
                    case "KeyD":
                        moveRight = false;
                        break;
                }
            });
            window.addEventListener("resize", () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                const s = 0.5;
                renderTarget.setSize(
                    window.innerWidth * s,
                    window.innerHeight * s,
                );
                composerScene.children[0].material.uniforms.resolution.value.set(
                    window.innerWidth * s,
                    window.innerHeight * s,
                );
            });
            document.addEventListener("click", () =>
                document.body.requestPointerLock(),
            );
            document.addEventListener("pointerlockchange", () => {
                document
                    .getElementById("ui")
                    .classList.toggle(
                        "hidden",
                        document.pointerLockElement === document.body,
                    );
            });
            document.addEventListener("mousemove", (e) => {
                if (document.pointerLockElement === document.body) {
                    camera.rotation.y -= e.movementX * 0.002;
                    camera.rotation.x -= e.movementY * 0.002;
                    camera.rotation.x = Math.max(
                        -Math.PI / 2,
                        Math.min(Math.PI / 2, camera.rotation.x),
                    );
                }
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now();
            const delta = (time - prevTime) / 1000;
            prevTime = time;

            if (cableShaderMat)
                cableShaderMat.uniforms.time.value = time * 0.001;

            updateChunks();

            velocity.x -= velocity.x * 10.0 * delta;
            velocity.z -= velocity.z * 10.0 * delta;
            velocity.y -= 9.8 * 3.0 * delta;

            direction.z = Number(moveForward) - Number(moveBackward);
            direction.x = Number(moveRight) - Number(moveLeft);
            direction.normalize();

            const speed = 60.0;
            if (moveForward || moveBackward)
                velocity.z -= direction.z * speed * delta;
            if (moveLeft || moveRight)
                velocity.x += direction.x * speed * delta;

            camera.translateX(velocity.x * delta);
            camera.translateZ(velocity.z * delta);
            camera.position.y += velocity.y * delta;

            if (camera.position.y < 2.0) {
                velocity.y = 0;
                camera.position.y = 2.0;
                canJump = true;
            }

            const isMoving =
                moveForward || moveBackward || moveLeft || moveRight;
            if (isMoving && canJump)
                camera.position.y += Math.sin(time * 0.012) * 0.15;

            // Hand & Flower Animation
            if (handsGroup) {
                handsGroup.userData.time += delta;
                const s = isMoving
                    ? Math.sin(handsGroup.userData.time * 10) * 0.05
                    : Math.sin(handsGroup.userData.time * 2) * 0.01;
                handsGroup.userData.left.rotation.z = -0.1 + s;
                handsGroup.userData.right.rotation.z = 0.1 - s;
                handsGroup.position.y =
                    Math.sin(handsGroup.userData.time * 2) * 0.02;

                const rHand = handsGroup.userData.right;
                rHand.children.forEach((child) => {
                    if (child.userData.bloom) {
                        const bloom = child.userData.bloom;
                        bloom.rotation.y += delta * 0.2;
                        bloom.children.forEach((part) => {
                            const ud = part.userData;
                            const t = time * 0.001;
                            if (ud.animType === "PETAL_BREATHE") {
                                const openAmount =
                                    Math.sin(t * 2.0 + ud.phase) * 0.2;
                                part.rotation.x = ud.baseRotX + openAmount;
                            }
                            if (ud.animType === "SEPAL_FLOAT") {
                                part.rotation.x += delta * 0.5;
                                part.rotation.z += delta * 0.3;
                                part.position.y =
                                    0.1 +
                                    Math.sin(t * 1.5 + ud.phase) * 0.05;
                            }
                            if (ud.animType === "DUST_ORBIT") {
                                part.position.applyAxisAngle(
                                    ud.axis,
                                    ud.speed * delta,
                                );
                            }
                        });
                    }
                });
            }

            if (skyEyeGroup) {
                skyEyeGroup.children.forEach((ring, idx) => {
                    if (ring.userData.speed) {
                        ring.rotation.z += ring.userData.speed * delta;
                        ring.rotation.x +=
                            ring.userData.speed * 0.5 * delta;
                    }
                });
            }

            if (scannerLight) {
                const scanSpeed = 0.0005;
                const scanRadius = 100;
                scannerLight.target.position.set(
                    Math.sin(time * scanSpeed) * scanRadius,
                    0,
                    Math.cos(time * scanSpeed) * scanRadius,
                );
                scannerLight.target.updateMatrixWorld();
            }

            const t = time * 0.001;

            for (const key in activeChunks) {
                const chunk = activeChunks[key];
                if (chunk.userData.buildings) {
                    chunk.userData.buildings.forEach((group) => {
                        const ud = group.userData;
                        if (ud.isMobile) {
                            const driftTime =
                                t * ud.wanderSpeed + ud.offset;
                            group.position.x =
                                ud.initialPos.x +
                                Math.sin(driftTime) * ud.wanderRange;
                            group.position.z =
                                ud.initialPos.z +
                                Math.cos(driftTime * 0.7) * ud.wanderRange;
                            group.position.y =
                                ud.initialPos.y +
                                Math.sin(driftTime * 0.5) * 2.0;
                        }
                        group.traverse((obj) => {
                            const mud = obj.userData;
                            if (mud) {
                                if (mud.animType === "ROTATE_FLOAT") {
                                    obj.rotation.x += mud.speed * delta;
                                    obj.rotation.z += mud.speed * delta;
                                }
                                if (mud.animType === "BREATHE") {
                                    const s =
                                        1 +
                                        Math.sin(
                                            t * mud.speed + mud.phase,
                                        ) *
                                        0.2;
                                    if (mud.baseScale)
                                        obj.scale.set(
                                            mud.baseScale.x * s,
                                            mud.baseScale.y * s,
                                            mud.baseScale.z * s,
                                        );
                                }
                                if (mud.animType === "SQUISH") {
                                    const sx =
                                        1 +
                                        Math.sin(
                                            t * mud.speed + mud.phase,
                                        ) *
                                        0.1;
                                    const sy =
                                        1 +
                                        Math.cos(
                                            t * mud.speed + mud.phase,
                                        ) *
                                        0.1;
                                    if (mud.baseScale)
                                        obj.scale.set(
                                            mud.baseScale.x * sx,
                                            mud.baseScale.y * sy,
                                            mud.baseScale.z * sx,
                                        );
                                }
                                if (mud.animType === "LIQUID_WOBBLE") {
                                    const s = Math.sin(
                                        t * mud.speed + mud.phase,
                                    );
                                    const sy = 1.0 + s * 0.15;
                                    const sxz = 1.0 - s * 0.07;
                                    if (mud.baseScale)
                                        obj.scale.set(
                                            mud.baseScale.x * sxz,
                                            mud.baseScale.y * sy,
                                            mud.baseScale.z * sxz,
                                        );
                                }
                                if (mud.animType === "BRANCH_SWAY") {
                                    const sway =
                                        Math.sin(
                                            t * mud.speed + mud.phase,
                                        ) *
                                        0.05 *
                                        (1.0 / mud.rigidity);
                                    obj.rotation.z = mud.initialRotZ + sway;
                                    obj.rotation.y +=
                                        Math.cos(t * 0.5 + mud.phase) *
                                        0.002;
                                }
                                if (mud.animType === "LEAF_FLUTTER") {
                                    obj.rotation.x +=
                                        Math.sin(t * 5.0 + mud.phase) *
                                        0.05;
                                    obj.rotation.z +=
                                        Math.cos(t * 3.0 + mud.phase) *
                                        0.05;
                                }
                                if (mud.isPlasma) {
                                    const pulse =
                                        0.5 +
                                        Math.sin(t * 2 + obj.position.x) *
                                        0.5;
                                    if (obj.material.emissive)
                                        obj.material.emissive.setHSL(
                                            0,
                                            0,
                                            pulse * 0.2,
                                        );
                                }
                            }
                        });
                    });
                }
                if (chunk.userData.cables) {
                    chunk.userData.cables.forEach((c) => {
                        let pStart;
                        if (c.startNode.isGround)
                            pStart = c.startNode.obj.position
                                .clone()
                                .add(c.options.offsetS);
                        else
                            pStart = c.startNode.obj.position
                                .clone()
                                .add(c.startNode.topOffset)
                                .add(c.options.offsetS);
                        let pEnd;
                        if (c.endNode.isGround)
                            pEnd = c.endNode.obj.position
                                .clone()
                                .add(c.options.offsetE);
                        else
                            pEnd = c.endNode.obj.position
                                .clone()
                                .add(c.endNode.topOffset)
                                .add(c.options.offsetE);
                        const positions =
                            c.line.geometry.attributes.position.array;
                        const mid = new THREE.Vector3()
                            .addVectors(pStart, pEnd)
                            .multiplyScalar(0.5);
                        const dist = pStart.distanceTo(pEnd);
                        let currentDroop = Math.max(
                            0,
                            c.options.droop - dist * 0.1,
                        );
                        if (c.options.heavySag) currentDroop += 20;
                        mid.y -= currentDroop;
                        let prevP = pStart.clone();
                        let idx = 0;
                        positions[idx++] = pStart.x;
                        positions[idx++] = pStart.y;
                        positions[idx++] = pStart.z;
                        for (let j = 1; j <= c.segments; j++) {
                            const t = j / c.segments;
                            const x =
                                (1 - t) * (1 - t) * pStart.x +
                                2 * (1 - t) * t * mid.x +
                                t * t * pEnd.x;
                            const y =
                                (1 - t) * (1 - t) * pStart.y +
                                2 * (1 - t) * t * mid.y +
                                t * t * pEnd.y;
                            const z =
                                (1 - t) * (1 - t) * pStart.z +
                                2 * (1 - t) * t * mid.z +
                                t * t * pEnd.z;
                            const clampedY = Math.max(0.1, y);
                            positions[idx++] = x;
                            positions[idx++] = clampedY;
                            positions[idx++] = z;
                        }
                        c.line.geometry.attributes.position.needsUpdate = true;
                    });
                }
            }

            renderer.setRenderTarget(renderTarget);
            renderer.render(scene, camera);
            renderer.setRenderTarget(null);
            renderer.render(composerScene, composerCamera);
        }

        init();
    </script>
</body>

</html>